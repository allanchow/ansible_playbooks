#jinja2: lstrip_blocks: "True", trim_blocks: "True"
# {{ ansible_managed }}

{% for mod in modules %}
load_module {{ mod }};
{% endfor %}

pcre_jit                         on;
worker_shutdown_timeout          1m;
# Each connection needs a filehandle (or 2 if you are proxying)
worker_rlimit_nofile         393216;
worker_priority                  -2;
user                         {{ nginx.user }} {{ nginx.user }};

events {
  worker_connections         102400;
  worker_aio_requests           256;
  use                         epoll;
  multi_accept                   on;
  accept_mutex                  off;
  accept_mutex_delay          500ms;
}

http {
  lua_code_cache               on;
  lua_package_path             "{{ nginx_root }}/modules/?.lua;;";
  lua_package_cpath            "{{ nginx_root }}/modules/lua/?.so;;";
  lua_socket_pool_size         30;
  lua_max_running_timers       4096;
  lua_max_pending_timers       16384;
  #lua_socket_log_errors       off;

  init_by_lua_file             "{{ nginx.conf_root }}/conf.d/lua_init";
  header_filter_by_lua_file    "{{ nginx.conf_root }}/conf.d/lua_header";
  log_by_lua_file              "{{ nginx.conf_root }}/conf.d/lua_log";

  lua_shared_dict ip_limit_pool    100m;
  lua_shared_dict memc_cache       {{ memcached.max_slab_page }};
  lua_shared_dict memc_cache_lock  100k;

  init_worker_by_lua_block {

    math.randomseed()

    local ngx_log = ngx.log
    local len = string.len

    local function dlog(ctx, ...)
      ngx_log(ngx.DEBUG, ...)
    end

    local function error_log(ctx, ...)
      ngx_log(ngx.ERR, ...)
    end

    local function warn(ctx, ...)
      ngx_log(ngx.WARN, ...)
    end

    local meta_shdict_set, meta_shdict_get  = (require "resty.shdict.simple").gen_shdict_methods{
        dict_name = "memc_cache",
        debug_logger = dlog,
        error_logger = error_log,
        positive_ttl = 20000,
        negative_ttl = 10000,
    }

    memc_fetch, memc_store = (require "resty.memcached.shdict_mod").gen_memc_methods{
        tag = "memc_static_cache",
        debug_logger = dlog,
        warn_logger = warn,
        error_logger = error_log,

        locks_shdict_name = "memc_cache_lock",

        shdict_set = meta_shdict_set,  -- generated by lua-resty-shdict-simple or
                                       -- any other API compatible function factories

        shdict_get = meta_shdict_get,  -- ditto

        disable_shdict = false,  -- optional, default false

        {% if memcached.connection == "tcp" %}
        memc_host = "{{ memcached.tcp.cluster_ip }}",
        memc_port = {{ memcached.tcp.cluster_port }}),
        {% else %}
        memc_host = "unix:{{ memcached.unix.socket }}",
        {% endif %}
        memc_timeout = 200,  -- in ms
        memc_conn_pool_size = {{ memcached.reqs_per_event }},
        memc_fetch_retries = 2,  -- optional, default 1
        memc_fetch_retry_delay = 100, -- in ms, optional, default to 100 (ms)

        memc_conn_max_idle_time = 10 * 1000,  -- in ms, for in-pool connections,
                                              -- optional, default to nil

        memc_store_retries = 2,  -- optional, default to 1
        memc_store_retry_delay = 100,  -- in ms, optional, default to 100 (ms)

        store_ttl = {{ memcached.default_ttl }},  -- in seconds, optional, default to 0 (i.e., never expires)
    }

    function delayed_memc_store(premature, ...)
      memc_store(...)
    end

--    es_access_logger_udp = require "resty.logger.socket_mod"
    local es_access_logger_udp = require "resty.logger.socket1"
    if not es_access_logger_udp.initted() then
      local rand = math.random
      local flush = 15 + tonumber(rand(0,10))
      local ok, err = es_access_logger_udp.init {
        host = '{{ cdn.logstash.access_log.udp.host }}',
        port = {{ cdn.logstash.access_log.udp.port }},
        sock_type = 'udp',
        timeout = 2000,
        max_retry_times = 10,
        retry_interval = 500,
        max_buffer_reuse = 100,
        flush_limit = 1,
        drop_limit = {{ nginx.drop_limit_buffer_size }}
        -- periodic_flush = flush
      }
      if not ok then
        ngx_log(ngx.ERR, "failed to initialize the es_access_logger_udp:", err)
--        return
      end
    end
    {% if cdn.logstash.access_log.tcp is defined %}
    local es_access_logger_tcp = require "resty.logger.socket0"
    if not es_access_logger_tcp.initted() then
      local rand = math.random
      local flush = 15 + tonumber(rand(0,10))
      local ok, err = es_access_logger_tcp.init {
        host = '{{ cdn.logstash.access_log.tcp.host }}',
        port = {{ cdn.logstash.access_log.tcp.port }},
        sock_type = 'tcp',
        timeout = 2000,
        max_retry_times = 10,
        retry_interval = 1,
        retry_interval = 500,
        max_buffer_reuse = 100,
        pool_size = {{ nginx.tcp_keepalive_pool }},
        flush_limit = 1,
        drop_limit = {{ nginx.drop_limit_buffer_size }}
        -- periodic_flush = flush
      }
      if not ok then
        ngx_log(ngx.ERR, "failed to initialize the es_access_logger_tcp:", err)
--        return
      end
    end
    {% endif %}

    function es_log(msg, bytes)
      local out_bytes = bytes or len(msg)
      local logger = es_access_logger_udp
      if es_access_logger_tcp and out_bytes > 1400 then
        logger = es_access_logger_tcp
      end
      local bytes, err = logger.log(msg)
      if err then
        ngx_log(ngx.ERR, "failed to log message:", err)
        return
      end
    end

    function limit_req(key, shm, rps, burst, extra_delay_on_overburst)
      local limitreq = require "resty.limit.req"
      local exit = ngx.exit
      local sleep = ngx.sleep
      local remote_addr = ngx.var.remote_addr
      local lim, err = limitreq.new(shm, rps, burst)
      if not lim then log(ngx.ERR, "failed to instantiate a resty.limit.req object: ", err); return end
      local delay_sec, err = lim:incoming(key, true)
      if not delay_sec then
        if err == "rejected" then
          ngx_log(ngx.CRIT, remote_addr," reaches global rps limit > ", rps+burst)
          return exit(ngx.HTTP_TOO_MANY_REQUESTS)
        end
        ngx_log(ngx.ERR, "failed to limit req:", err)
        return
      end
      if delay_sec > 0 then
--        local excess = err
        ngx_log(ngx.WARN, remote_addr," reaches global rps limit > ", rps, " and < ", rps+burst, ", excess rps: ", err, ", delay: ", delay_sec, "s")
--        sleep(extra_delay_on_overburst+delay_sec)
      end
    end
  }
  access_by_lua_block {
    local range              = ngx.var.http_range
    local binary_remote_addr = ngx.var.binary_remote_addr

    -- CVE-2015-1635, if it matches a string of 10 or more integers, remove it
    if range then
      local find          = ngx.re.find
      -- the max byte range is ~ 953M
      local from, to, err = find(range, [[\d{10,}]], "isjou")
      if from then
        ngx.log(ngx.WARN, "CVE-2015-1635, bad range: ", range)
        return ngx.exit(ngx.HTTP_BAD_REQUEST)
      end
    end

    limit_req(binary_remote_addr, "ip_limit_pool", 1000, 50, 1)
  }

  #access_by_lua_file           "/usr/local/nginx/modules/l7/runtime.lua";
  #lua_shared_dict guard_dict    100m;
  #lua_shared_dict dict_captcha  70m;

  include                      conf.d/mime.types;
  include                      conf.d/gzip.conf;

  default_type                 application/octet-stream;
  charset_types  text/xml text/plain text/vnd.wap.wml application/x-javascript application/rss+xml text/css application/javascript application/json;

  server_tokens                  off;
  server_name_in_redirect        off;
  server_names_hash_max_size    2048;
  server_names_hash_bucket_size  256;

  port_in_redirect             off;

  lingering_close               on;
  lingering_time               30s;
  lingering_timeout             5s;

  recursive_error_pages         on;
  ignore_invalid_headers        on;
  underscores_in_headers        on;

  client_body_timeout          15s;
  client_header_timeout        15s;
  client_body_buffer_size     128k;
  client_header_buffer_size     1k;
  client_max_body_size          8m;
  large_client_header_buffers 2 1k;

  open_file_cache              max=10000 inactive=20s;
  open_file_cache_valid        30s;
  open_file_cache_min_uses       2;
  open_file_cache_errors        on;

  aio                          threads=default;
#  aio                      threads;
  directio                      8m;
  directio_alignment            {{ pbsz }};

# sendfile is useful for lower latency as it bypasses userspace stack => zero copy
  sendfile                      on;

# time out between successive write operations
# if the tcp_wmem init value is too large and client cannot drain the socket buffer
# faster than the send_timeout, the client connection will be closed.
# It is desirable to shorten the time in normal, but it will hinder the large file
# download operation
# html => lower send_timeout, lower tcp_wmem
# static assets => higher send_timeout, higher tcp_wmem
  send_timeout                 10s;

# Lower send_timeout could help to protect the web server that allow more connections
# Higher tcp_wmem will higher throughtput
# To adapt this criteria, any unacknowledged data in the socket buffer is determined
# when send_timeout reaches. If the line is above the min send rate, keep sending rather
# than close the connections
  send_minimum_rate            10k;  # Bps

#  sendfile_max_chunk          512k;

# set RST abrutly
  reset_timedout_connection     on;

  tcp_nopush                   off;
  output_buffers            1  32k;
  max_ranges                     1;

  tcp_nodelay                   on;
  keepalive_timeout         10s 5s;
  keepalive_requests           512;

  postpone_output             1400;  # postpone output unti a MTU is filled up

  resolver                    127.0.0.1 valid=60s;
  resolver_timeout               10s;

#  dav_methods                  off;
  merge_slashes                 on;

  # Improved SSL settings, see https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html
  # Test SSL security: https://www.ssllabs.com/ssltest/analyze.html?d=developer.zargony.com&hideResults=on
  # https://wiki.mozilla.org/Security/Server_Side_TLS
  #ssl_ciphers kEECDH+ECDSA+AES128:kEECDH+ECDSA+AES256:kEECDH+AES128:kEECDH+AES256:kEDH+AES128:kEDH+AES256:DES-CBC3-SHA:+SHA:!aNULL:!eNULL:!LOW:!kECDH:!DSS:!MD5:!EXP:!PSK:!SRP:!CAMELLIA:!SEED;
  #ssl_ciphers "ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!LOW:!kECDH:!DSS:!EXP:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA:!SEED:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA";
  ssl_ciphers ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!aNULL:!eNULL:!LOW:!kECDH:!DSS:!MD5:!EXP:!PSK:!SRP:!CAMELLIA:!SEED;

  ssl_ecdh_curve            prime256v1:secp384r1;

  ssl_prefer_server_ciphers on;
  ssl_protocols             TLSv1 TLSv1.1 TLSv1.2;
  ssl_session_cache         shared:SSL:10m;  # 10MB -> ~40,000 sessions.
  ssl_session_timeout       10m;
  # https://www.igvita.com/2013/12/16/optimizing-nginx-tls-time-to-first-byte/
  # Defaults to 1369 bytes (designed to fit the entire record in a single TCP segment: 1369 = 1500 - 40 (IPv6) - 20 (TCP) - 10 (Time) - 61 (Max TLS overhead))
  ssl_buffer_size           1369;

  ssl_dhparam               {{ nginx.cert_root }}/{{ ssl.dhparam }};
  ssl_session_tickets       on;
  ssl_session_ticket_key    {{ nginx.cert_root }}/{{ ssl.session_key }};

#  ssl_stapling              on;
#  ssl_stapling_verify       on;

  map $http_upgrade $connection_upgrade {
    default upgrade;
    ""      close;
  }
  map $scheme $ssl_upstream {
    default "";
    "https" "_ssl";
  }
  map 1 $_resource_id {
    default "";
  }

  error_page     400 =444;

  access_log off;
  error_log syslog:server={{ cdn.logstash.error_log.udp.host }}:{{ cdn.logstash.error_log.udp.port }} warn;

  include {{ nginx.conf_root }}/conf.d/no-default;
  include {{ nginx.resource_root }}/*.conf;
  include {{ nginx.customers_root }}/*.conf;
}
