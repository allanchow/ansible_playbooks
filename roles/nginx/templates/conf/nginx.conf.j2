#jinja2: lstrip_blocks: "True", trim_blocks: "True"
# {{ ansible_managed }}

{% for mod in modules %}
load_module {{ mod }};
{% endfor %}

pcre_jit                         on;
worker_shutdown_timeout          1m;
# Each connection needs a filehandle (or 2 if you are proxying)
worker_rlimit_nofile         393216;
worker_priority                  -2;

events {
  worker_connections         102400;
  worker_aio_requests           256;
  use                         epoll;
  multi_accept                   on;
  accept_mutex                  off;
  accept_mutex_delay          500ms;
}

http {
  lua_code_cache               on;
  lua_package_path             "{{ nginx_root }}/modules/?.lua;;";
  lua_package_cpath            "{{ nginx_root }}/modules/lua/?.so;;";

  init_by_lua_file             "{{ nginx.conf_root }}/conf.d/lua_init";
  header_filter_by_lua_file    "{{ nginx.conf_root }}/conf.d/lua_header";
  log_by_lua_file              "{{ nginx.conf_root }}/conf.d/lua_log";

  lua_shared_dict ip_limit_pool 100m;
  init_worker_by_lua_block {

    math.randomseed()

    es_access_logger = require "resty.logger.socket0"
    if not es_access_logger.initted() then
      local rand = math.random
      local flush = 15 + tonumber(rand(0,10))
      local ok, err = es_access_logger.init {
        host = '{{ cdn.logstash.access_log.udp.host }}',
        port = {{ cdn.logstash.access_log.udp.port }},
        sock_type = 'udp',
        timeout = 2000,
        max_retry_times = 10,
        retry_interval = 500,
        max_buffer_reuse = 100,
        pool_size = {{ nginx.tcp_keepalive_pool }},
        flush_limit = 1,
        drop_limit = {{ nginx.udp_buffer_size }}
        -- periodic_flush = flush
      }
      if not ok then
        ngx.log(ngx.ERR, "failed to initialize the es_access_logger:", err)
        return
      end
    end
    function es_log(logger, msg)
      local deflated = zlib.deflate()(mp.pack({{'{{'}}message=msg{{'}}'}}), 'finish')
      local bytes, err = logger.log(deflated)
      if err then
        ngx.log(ngx.ERR, "failed to log message:", err)
        return
      end
    end
    function limit_req(key, shm, rps, burst, extra_delay_on_overburst)
      local limitreq = require "resty.limit.req"
      local exit = ngx.exit
      local log = ngx.log
      local sleep = ngx.sleep
      local lim, err = limitreq.new(shm, rps, burst)
      if not lim then log(ngx.ERR, "failed to instantiate a resty.limit.req object: ", err); return end
      local delay, err = lim:incoming(key, true)
      if not delay then
        if err == "rejected" then return exit(ngx.HTTP_TOO_MANY_REQUESTS) end
        log(ngx.ERR, "failed to limit req:", err)
        return
      end
      if delay > 0 then
        local excess = err
        sleep(extra_delay_on_overburst+delay)
      end
    end
  }
  access_by_lua_block {
    limit_req(ngx.var.binary_remote_addr, "ip_limit_pool", 500, 50, 1)
  }

  #access_by_lua_file           "/usr/local/nginx/modules/l7/runtime.lua";
  #lua_shared_dict guard_dict    100m;
  #lua_shared_dict dict_captcha  70m;

  include                      conf.d/mime.types;
  include                      conf.d/gzip.conf;

  default_type                 application/octet-stream;
  charset_types  text/xml text/plain text/vnd.wap.wml application/x-javascript application/rss+xml text/css application/javascript application/json;

  server_tokens                off;
  server_name_in_redirect      off;
  server_names_hash_max_size  2048;
  server_names_hash_bucket_size 256;

  lingering_close               on;
  lingering_time               30s;
  lingering_timeout             5s;

  recursive_error_pages         on;
  ignore_invalid_headers        on;
  underscores_in_headers        on;

  client_body_timeout          10s;
  client_header_timeout        10s;
  client_body_buffer_size     128k;
  client_header_buffer_size     1k;
  client_max_body_size          8m;
  large_client_header_buffers 2 1k;

  open_file_cache              max=10000 inactive=20s;
  open_file_cache_valid        30s;
  open_file_cache_min_uses       2;
  open_file_cache_errors        on;

  aio                          threads=default;
#  aio                      threads;
  directio                      8m;
  directio_alignment            {{ pbsz }};

  send_timeout                 10s;
  reset_timedout_connection     on;
  sendfile                      on;
  sendfile_max_chunk          512k;

  tcp_nopush                    on;
  output_buffers            1  32k;
  max_ranges                     1;

  tcp_nodelay                   on;
  keepalive_timeout         10s 5s;
  keepalive_requests           512;

  postpone_output             1400;  # postpone output unti a MTU is filled up

  resolver                    8.8.8.8 8.8.4.4 valid=60s;
  resolver_timeout               5s;

#  dav_methods                  off;
  merge_slashes                 on;

  # Improved SSL settings, see https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html
  # Test SSL security: https://www.ssllabs.com/ssltest/analyze.html?d=developer.zargony.com&hideResults=on
  # https://wiki.mozilla.org/Security/Server_Side_TLS
  #ssl_ciphers kEECDH+ECDSA+AES128:kEECDH+ECDSA+AES256:kEECDH+AES128:kEECDH+AES256:kEDH+AES128:kEDH+AES256:DES-CBC3-SHA:+SHA:!aNULL:!eNULL:!LOW:!kECDH:!DSS:!MD5:!EXP:!PSK:!SRP:!CAMELLIA:!SEED;
  #ssl_ciphers "ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!LOW:!kECDH:!DSS:!EXP:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA:!SEED:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA";
  ssl_ciphers ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!aNULL:!eNULL:!LOW:!kECDH:!DSS:!MD5:!EXP:!PSK:!SRP:!CAMELLIA:!SEED;

  ssl_ecdh_curve            prime256v1:secp384r1;

  ssl_prefer_server_ciphers on;
  ssl_protocols             TLSv1 TLSv1.1 TLSv1.2;
  ssl_session_cache         shared:SSL:10m;  # 10MB -> ~40,000 sessions.
  ssl_session_timeout       10m;
  # https://www.igvita.com/2013/12/16/optimizing-nginx-tls-time-to-first-byte/
  # Defaults to 1369 bytes (designed to fit the entire record in a single TCP segment: 1369 = 1500 - 40 (IPv6) - 20 (TCP) - 10 (Time) - 61 (Max TLS overhead))
  ssl_buffer_size           1369;

  ssl_dhparam               {{ nginx.cert_root }}/{{ ssl.dhparam }};
  ssl_session_tickets       on;
  ssl_session_ticket_key    {{ nginx.cert_root }}/{{ ssl.session_key }};

#  ssl_stapling              on;
#  ssl_stapling_verify       on;

  map $http_upgrade $connection_upgrade {
    default upgrade;
    ""      close;
  }
  map $scheme $ssl_upstream {
    default "";
    "https" "_ssl";
  }
  #CVE-2015-1635, if it matches a string of 10 or more integers, remove it
  map $http_range $_is_safe_range {
    default    1;
    "~\d{10,}" 0;
  }

  error_page     400 =444;

  access_log off;
  error_log syslog:server={{ cdn.logstash.error_log.udp.host }}:{{ cdn.logstash.error_log.udp.port }} error;

  # server {
  #   listen 8081;
  #   location / { dyups_interface; }
  # }

  upstream memc_cluster {
    {% if memcached.connection == "tcp" %}
    server {{ memcached.tcp.cluster_ip }}:{{ memcached.tcp.cluster_port }} fail_timeout=2s;
    {% else %}
    server unix:{{ memcached.unix.socket }};
    {% endif %}
    keepalive 16;
#    consistent_hash $key;
  }

  include {{ nginx.conf_root }}/conf.d/no-default;
  include {{ nginx.resource_root }}/*.conf;
  include {{ nginx.customers_root }}/*.conf;
}
